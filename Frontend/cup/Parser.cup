/*
  CUP Parser
*/

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import edu.tum.lua.ast.*;


/* Preliminaries to use the scanner.  */
scan with {: return lexer.next_token(); :};


parser code {: 
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex) {
  		
      super(lex);
      lexer = lex;
     
  }

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    
    System.out.print(message);
    
    if ( !(info instanceof Symbol) ) return;
    Symbol symbol = (Symbol) info;
    
    if ( symbol.left < 0 || symbol.right < 0 ) return;
    
    System.out.println(" at line "+symbol.left+", column "+symbol.right);
  }
:}; 





 /* Terminals (tokens returned by lexer). */

terminal         ADD, MUL, SUB, DIV, MOD, POW, CONCAT;
terminal         AND, OR, NOT, LENGTH;
terminal 		 LPAREN, RPAREN, LBRACK, RBRACK, LCURL, RCURL;
terminal         ASM; //Assigment =
terminal		 DOT, DDOT;
terminal         EQ, LEQ ,NEQ , LE, GR, GEQ;
terminal		 LOCAL, FUNC, END;
terminal  		 DO, WHILE, FOR, IN, REPEAT, UNTIL;
terminal         IF, THEN, ELSE, ELSEIF, RETURN, BREAK;
terminal         NIL, FALSE, TRUE, PARAMS;
terminal		 SEMI, COM, WS;

terminal Double NUMBER;
terminal String  ID, TEXT;



 /*NON TERMINALS */
non terminal Chunk chunk;
non terminal Block block;
non terminal Stat stat;
non terminal StatList statlist;
non terminal LastStat laststat;

non terminal FuncName funcname;
non terminal IfThenElse optelse;
non terminal VarList varlist;
non terminal Var var;
non terminal NameList namelist;
non terminal ExpList explist;
non terminal Exp exp;
non terminal PrefixExp prefixexp;
non terminal FunctionCall functioncall;
non terminal args;
non terminal Function function;
non terminal FuncBody funcbody;
non terminal ParList parlist;
non terminal TableConstructor tableconstructor;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal fieldsep;
non terminal Integer binop;
non terminal Integer unop;
non terminal optsemi, empty, optws, optforexp, optexplist, optasm, optdotname, optcolonname, optvarlist;


/* Grammar */



block 			::=     statlist:stats 
                 		{:                 	    
                 		RESULT = new Block(stats,null);
                 		:}
                 		
                 		;



statlist		::=		stat:s SEMI WS
						{: 				
						RESULT = new StatList(s);
						:}	
						|  stat:s SEMI WS statlist:sl 
						{:						
					    if(sl== null){
					    sl =new StatList(s);
						RESULT = sl;}
						else{
						sl.insertElementAt(s,0);
						RESULT = sl;
						}
						:}				
						;
					
stat        	::=    	varlist:vl ASM explist:el 
						{: 
						RESULT = new Asm(vl,el);
						:}
						
						;
						
						
varlist			::=     var:v
						{: 							
						RESULT= new VarList(v);
						:}
						| var:v COM varlist:vl
						{: 
						if(vl==null){
						vl = new VarList(v);
						RESULT = vl; }
						else {
						vl.insertElementAt(v,0);
						RESULT = vl; }
						:}								
						;
						
explist			::=     exp:e
						{:
						RESULT= new ExpList(e);
						:}
						| exp:e COM explist:el
						{:
						if(el == null) {
						el = new ExpList(e);
						RESULT = el;} 
						else {
						el.insertElementAt(e,0);
						RESULT = el;} :}
						
						
						;
						
var				::=		ID:id
						{:  						
						RESULT =  new Variable(id);
						
						:}						
						;
						
exp				::=		
						NUMBER:num
						{: 
					  
						RESULT = new NumberExp(num); 
						
						:} 
						
						;	
						
						
empty			::=		;