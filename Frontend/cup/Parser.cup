/*
  CUP Parser
*/

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import edu.tum.lua.ast.*;


/* Preliminaries to use the scanner.  */
scan with {: return lexer.next_token(); :};


parser code {: 
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex) {
  		
      super(lex);
      lexer = lex;
     
  }

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    
    System.out.print(message);
    
    if ( !(info instanceof Symbol) ) return;
    Symbol symbol = (Symbol) info;
    
    if ( symbol.left < 0 || symbol.right < 0 ) return;
    
    System.out.println(" at line "+symbol.left+", column "+symbol.right);
  }
:}; 



 /* Terminals (tokens returned by lexer). */

terminal         ADD, MUL, SUB, DIV, MOD, POW, CONCAT;
terminal         AND, OR, NOT, LENGTH;
terminal 		 LPAREN, RPAREN, LBRACK, RBRACK, LCURL, RCURL;
terminal         ASM; //Assigment =
terminal		 DOT, DDOT;
terminal         EQ, LEQ ,NEQ , LE, GR, GEQ;
terminal		 LOCAL, FUNC, END;
terminal  		 DO, WHILE, FOR, IN, REPEAT, UNTIL;
terminal         IF, THEN, ELSE, ELSEIF, RETURN, BREAK;
terminal         NIL, FALSE, TRUE, PARAMS;
terminal		 SEMI, COM, WS;

terminal Double Number;
terminal String  Id;


 /*NON TERMINALS */
non terminal Chunk chunk;
non terminal Block block;
non terminal Stat stat;
non terminal StatList statlist;
non terminal LastStat laststat;
non terminal FuncName funcname;
non terminal IfThenElse optelse;
non terminal VarList varlist;
non terminal Var var;
non terminal NameList namelist;
non terminal ExpList explist;
non terminal Exp exp;
non terminal PrefixExp prefixexp;
non terminal FunctionCall functioncall;
non terminal Args args;
non terminal Function function;
non terminal FuncBody funcbody;
non terminal ParList parlist;
non terminal TableConstructor tableconstructor;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal FieldSep fieldsep;
non terminal BinOp binop;
non terminal UnOp unop;
non terminal optsemi, empty, optws, optforexp, optexplist, optasm, optdotname, optcolonname;


/* Grammar */

empty 		::=  /* nothing */;
chunk 		::=      statlist:stats
                 	{:  RESULT = new Chunk(stats); :}
                 
                 	|   statlist: stats laststat:last
                 	{:  RESULT = new Chunk(stats, last); :}
                 	;

statlist    ::=      stat:s optsemi statlist:stats 
					{:  RESULT = new Statlist(s, stats); :}
					|
					 stat:s optws statlist:stats 
                 	{:  RESULT = new Statlist(s, stats); :}
                 	;
				
optsemi		::= 	SEMI | empty;

optws		::= 	WS | empty;

block       ::=     chunk:c
				 	{: RESULT = new Block(c); :}
					;
					
					
stat        ::=     varlist:vl ASM explist:el
					{: RESULT = new Stat(vl,el); :}
				
					| functioncall:fcall
					{: RESULT = new FunctionCall(fcall); :}
				
					| DO block:b END 
					{: RESULT = new Do(b); :}
				
         			| WHILE exp:e DO block:b END
					{: RESULT = new While(e,b); :}
					
					| REPEAT block:b UNTIL exp:e
					{: RESULT = new While(e,b); :}
					
					| IF exp:e THEN block:b optelse:elseblock END
					{: RESULT = new IfThenElse(e,b,elseblock); :}

					| FOR Id:id ASM exp:e1 COM exp:e2 optforexp:e3 DO block:b END
					{: RESULT = new For(id,e1,e2,e3,b); :}
					
					| FOR namelist:nl IN explist:el DO block:b END
					{: RESULT = new ForIn(nl,el,b); :}
					
					| FUNC funcname:fn funcbody:fb
					{: RESULT = new FunctionDef(fn,fb); :}
					
					| LOCAL FUNC funcname:fn funcbody:fb
					{: RESULT = new LocalFuncDef(fn,fb); :}
					
					| LOCAL namelist:nl optasm optexplist:oel
					{: RESULT = new LocalDecl(nl,oel); :}
					;
					
					
optforexp   ::=     COM exp:e {: RESULT = e; :}				
					| {: RESULT = 1; :}
					;

optexplist  ::= 	explist:el {: RESULT = el; :}	
					| empty
					;	

optasm  ::= 	ASM {: RESULT = ASM; :}	
					| empty
					;	

optelse		::= 	ELSE block:b {: RESULT = b; :}	
					| empty
					;	
					
laststat	::=		RETURN optexplist:el {: RESULT = el; :}		
					| BREAK 
					| empty
					;

funcname	::=		Id:id optdotname:id1 optcolonname:id2;


				  
