/*
  CUP Parser
*/

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import edu.tum.lua.ast.*;


/* Preliminaries to use the scanner.  */
scan with {: return lexer.next_token(); :};


parser code {: 
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex) {
  		
      super(lex);
      lexer = lex;
     
  }

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    
    System.out.print(message);
    
    if ( !(info instanceof Symbol) ) return;
    Symbol symbol = (Symbol) info;
    
    if ( symbol.left < 0 || symbol.right < 0 ) return;
    
    System.out.println(" at line "+symbol.left+", column "+symbol.right);
  }
:}; 





 /* Terminals (tokens returned by lexer). */


terminal         ASM; //Assigment =
terminal		 DOT, DDOT;
terminal		 LOCAL, FUNC, END;
terminal  		 DO, WHILE, FOR, IN, REPEAT, UNTIL;
terminal         IF, THEN, ELSE, ELSEIF, RETURN, BREAK;
terminal         NIL, FALSE, TRUE, PARAMS;
terminal         ADD, MUL, SUB, DIV, MOD, POW, CONCAT;
terminal         EQ, LEQ ,NEQ , LE, GR, GEQ, AND, OR; 
terminal         NOT, LENGTH;
terminal 		 LPAREN, RPAREN, LBRACK, RBRACK, LCURL, RCURL;
terminal		 SEMI, COM, WS;
terminal Double NUMBER;
terminal String  ID, TEXT;




 /*NON TERMINALS */
non terminal Chunk chunk;
non terminal Block block, optelse ;
non terminal Stat stat;
non terminal StatList statlist;
non terminal LastStat laststat;

non terminal FuncName funcname;
non terminal IfThenElse ifthenelse;
non terminal VarList varlist;
non terminal Var var;
non terminal NameList namelist;
non terminal ExpList explist;
non terminal Exp exp, optforexp;
non terminal PrefixExp prefixexp;
non terminal FunctionCall functioncall;
non terminal ExpList args;
non terminal Function function;
non terminal FuncBody funcbody;
non terminal ParList parlist;
non terminal TableConstructor tableconstructor;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal fieldsep;
non terminal Integer binop;
non terminal Integer unop;
non terminal optsemi, empty, optws, optexplist, optasm, optdotname, optcolonname, optvarlist;

precedence left  ADD, MUL, SUB, DIV, MOD, POW, CONCAT, EQ, LEQ ,NEQ , LE, GR, GEQ, AND, OR;
/* Grammar */

start with block;


block 			::=     statlist:stats laststat:lstat
                 		{:       
                 			if(lstat == null)   {   
                 			System.out.println("Inside block");    	    
                 			RESULT = new Block(stats,null); 	}
                 			else	{
                 			System.out.println("Inside block with laststat");   
                 			RESULT = new Block(stats,lstat);  }
                 		:}
                 		| empty {:
                 			RESULT = new Block(null, null);
                 		:}
                 		;

	

statlist		::=		stat:s optsemi optws
						{: 	
							System.out.println("Inside single stat"); 			
							RESULT = new StatList(s);
						:}	
						
						|  stat:s optsemi optws statlist:sl 
						{:						
					   		if(sl== null){
					    	System.out.println("Inside recu stat"); 	
					    	sl =new StatList(s);
							RESULT = sl;}
							else{
							System.out.println("Inside recu stat");
							sl.insertElementAt(s,0);
							RESULT = sl;
							}
						:}	
									
						;
						
						
laststat		::=		RETURN optexplist:el 
						{:    
							System.out.println("Inside laststat");
							RESULT = new LastReturn( (ExpList) el); 
						:}		
						| 	BREAK {: RESULT = new LastBreak(); :}	
						| 	empty
						; 	
					
stat        	::=    		varlist:vl ASM explist:el 
						{: 
								System.out.println("Inside stat");
								RESULT = new Asm(vl,el);
						:}
						| 	DO WS block:b END 
						{:    
								System.out.println("Inside DO END");
								RESULT = new DoExp(b); 
						:}
						|  	WHILE optws exp:e  optws DO optws block:b END
						{: 		RESULT = new WhileExp(e,b); :}
						|  	REPEAT optws block:b  UNTIL optws exp:e
						{: 		RESULT = new RepeatUntil(b,e); :}
						|  	IF optws exp:e optws THEN optws block:b optelse:elseblock END
						{: 	RESULT = new IfThenElse(e, b, elseblock);
						:}
						| 	FOR optws ID:id optws ASM optws exp:e1 optws COM optws exp:e2  optforexp:e3 optws DO optws block:b END
						{: 		
								RESULT = new ForExp(id,e1,e2,e3,b); 
						:}
						| FOR optws namelist:nl  IN optws explist:el optws DO optws block:b END
						{: RESULT = new ForIn(nl,el,b); :}
						| functioncall:funccall
							{: RESULT = new FuncCallStmt(funccall); :}
						;
						
functioncall	::=		prefixexp:prefixexp args:args
						{: 
							RESULT = new FunctionCall(prefixexp, args);
							System.out.println("Returning FUNCCALL");
						:}
						;
						
args			::=		LPAREN explist:explist RPAREN
							{: 
								RESULT = explist; 
								System.out.println("Returning args");
							:}
						;

optelse			::= 	ELSE optws block:b {: RESULT = b; :}						
						| empty
						;	
												
optforexp		::=		COM optws exp:e {: RESULT = e; :}				
						| empty {: RESULT = new NumberExp(1.0); :}
						;

varlist			::=     var:v
						{: 							
						RESULT= new VarList(v);
						:}
						| var:v COM varlist:vl
						{: 
						if(vl==null){
						vl = new VarList(v);
						RESULT = vl; }
						else {
						vl.insertElementAt(v,0);
						RESULT = vl; }
						:}								
						;
						
explist			::=     exp:e 
							{:
							RESULT= new ExpList(e);
							:}
						| exp:e COM explist:el
							{:
								if(el == null) {
									el = new ExpList(e);
								RESULT = el;} 
								else {
									el.insertElementAt(e,0);
								RESULT = el;}
	
							:}
						;
						
namelist    	::=    	ID:id optws
						{: RESULT = new NameList(new Name(id)); :}  
						| ID:id COM namelist:nl
						{: 	if(nl== null){					    		
					    	nl =new NameList(new Name(id));
							RESULT = nl;}
							else{		
							nl.insertElementAt(new Name(id),0);
							RESULT = nl;
							} 
						:} 
						| empty												
						;
						
var				::=		ID:id
						{:  						
						RESULT =  new Variable(id);
						
						:}						
						;
						
exp				::=		NIL
							{: RESULT = new Nil(); :}  
						| FALSE
							{: RESULT = new BooleanExp(false); :}  
						| TRUE
							{: RESULT = new BooleanExp(true); :} 
						| NUMBER:num
							{: 					   
								RESULT = new NumberExp(num); 						
							:} 
						| ID:id 
							{: RESULT = new TextExp(id); :}
						| exp:e1 binop:op exp:e2
							{: RESULT = new Binop(e1,op,e2); :}
						| unop:uop exp:e
							{: RESULT = new Unop(uop,e); :}
						| prefixexp:prefixexp
							{: RESULT = new PreExp(prefixexp); :}
						;	
						
prefixexp		::=		LPAREN RPAREN;

binop			::=		ADD
						{: RESULT = Op.ADD; :}
						| SUB
						{: RESULT = Op.SUB; :}
						| MUL
						{: RESULT = Op.MUL; :}
						| DIV
						{: RESULT = Op.DIV; :}
						| MOD
						{: RESULT = Op.MOD; :}
						| POW
						{: RESULT = Op.POW; :}
						| CONCAT
						{: RESULT = Op.CONCAT; :}
						| EQ
						{: RESULT = Op.EQ; :}
						| LEQ
						{: RESULT = Op.LE; :}
						| NEQ
						{: RESULT = Op.NEQ; :}
						| LE
						{: RESULT = Op.LT; :}
						| GR
						{: RESULT = Op.GT; :}
						| GEQ
						{: RESULT = Op.GE; :}
						| AND
						{: RESULT = Op.AND; :}
						| OR
						{: RESULT = Op.OR; :}
						;
						
unop			::=		SUB
						{: RESULT = Op.UNM; :}
						| NOT
						{: RESULT = Op.NOT; :}
						| LENGTH
						{: RESULT = Op.LEN; :}
						;
								

						
optsemi			::= 	SEMI  | empty ;


optws			::= 	WS | empty ;
						
empty			::=		;