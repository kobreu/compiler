/*
  CUP Parser
*/

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import edu.tum.lua.ast.*;


/* Preliminaries to use the scanner.  */
scan with {: return lexer.next_token(); :};


parser code {: 
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex) {
  		
      super(lex);
      lexer = lex;
     
  }

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    
    System.out.print(message);
    
    if ( !(info instanceof Symbol) ) return;
    Symbol symbol = (Symbol) info;
    
    if ( symbol.left < 0 || symbol.right < 0 ) return;
    
    System.out.println(" at line "+symbol.left+", column "+symbol.right);
  }
:}; 



 /* Terminals (tokens returned by lexer). */

terminal         ADD, MUL, SUB, DIV, MOD, POW, CONCAT;
terminal         AND, OR, NOT, LENGTH;
terminal 		 LPAREN, RPAREN, LBRACK, RBRACK, LCURL, RCURL;
terminal         ASM; //Assigment =
terminal		 DOT, DDOT;
terminal         EQ, LEQ ,NEQ , LE, GR, GEQ;
terminal		 LOCAL, FUNC, END;
terminal  		 DO, WHILE, FOR, IN, REPEAT, UNTIL;
terminal         IF, THEN, ELSE, ELSEIF, RETURN, BREAK;
terminal         NIL, FALSE, TRUE, PARAMS;
terminal		 SEMI, COM, WS;

terminal Double NUMBER;
terminal String  ID, TEXT;


 /*NON TERMINALS */
non terminal Chunk chunk;
non terminal Block block;
non terminal Stat stat;
non terminal StatList statlist;
non terminal LastStat laststat;
non terminal FuncName funcname;
non terminal IfThenElse optelse;
non terminal VarList varlist;
non terminal Var var;
non terminal NameList namelist;
non terminal ExpList explist;
non terminal Exp exp;
non terminal PrefixExp prefixexp;
non terminal FunctionCall functioncall;
non terminal Args args;
non terminal Function function;
non terminal FuncBody funcbody;
non terminal ParList parlist;
non terminal TableConstructor tableconstructor;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal FieldSep fieldsep;
non terminal BinOp binop;
non terminal UnOp unop;
non terminal optsemi, empty, optws, optforexp, optexplist, optasm, optdotname, optcolonname, optvarlist;


/* Grammar */

empty 		::=  /* nothing */;
chunk 		::=      statlist:stats
                 	{:  RESULT = new Chunk(stats); :}
                 
                 	|   statlist: stats laststat:last
                 	{:  RESULT = new Chunk(stats, last); :}
                 	;

statlist    ::=      stat:s optsemi statlist:stats 
					{:  RESULT = new Statlist(s, stats); :}
					|
					 stat:s optws statlist:stats 
                 	{:  RESULT = new Statlist(s, stats); :}
                 	;
				
optsemi		::= 	SEMI | empty;

optws		::= 	WS | empty;

block       ::=     chunk:c
				 	{: RESULT = new Block(c); :}
					;
					
					
stat        ::=     varlist:vl ASM explist:el
					{: RESULT = new Asm(vl,el); :}
				
					| functioncall:fcall
					{: RESULT = new FuncCallStmt(fcall); :}
				
					| DO block:b END 
					{: RESULT = new DoExp(b); :}
				
         			| WHILE exp:e DO block:b END
					{: RESULT = new WhileExp(e,b); :}
					
					| REPEAT block:b UNTIL exp:e
					{: RESULT = new RepeatUntil(e,b); :}
					
					| IF exp:e THEN block:b optelse:elseblock END
					{: RESULT = new IfThenElse(e,b,elseblock); :}

					| FOR ID:id ASM exp:e1 COM exp:e2 optforexp:e3 DO block:b END
					{: RESULT = new ForExp(id,e1,e2,e3,b); :}
					
					| FOR namelist:nl IN explist:el DO block:b END
					{: RESULT = new ForIn(nl,el,b); :}
					
					| FUNC funcname:fn funcbody:fb
					{: RESULT = new FunctionDef(fn,fb); :}
					
					| LOCAL FUNC funcname:fn funcbody:fb
					{: RESULT = new LocalFuncDef(fn,fb); :}
					
					| LOCAL namelist:nl optasm optexplist:oel
					{: RESULT = new LocalDecl(nl,oel); :}
					;
					
					
optforexp   ::=     COM exp:e {: RESULT = e; :}				
					| {: RESULT = 1; :}
					;

optexplist  ::= 	explist:el {: RESULT = el; :}	
					| empty
					;	

optasm  	::= 	ASM {: RESULT = ASM; :}	
					| empty
					;	

optelse		::= 	ELSE block:b {: RESULT = b; :}	
					| empty
					;	
					
laststat	::=		RETURN optexplist:el {: RESULT = new LastReturn(el); :}		
					| BREAK {: RESULT = new LastBreak(); :}	
					| empty
					;

funcname	::=		ID:id optdotname:id1 optcolonname:id2			
					{: RESULT = new FuncName(id,id1,id2); :}
					;
					
varlist		::=    	var:v
					{: RESULT = new Var(v); :}
					| var:v COM varlist:vl
					{: RESULT = new VarList(vl.add(id)); :}
					;
/*					
optvarlist 	::=		COM var:v optvarlist:ovl
					{: RESULT = new VarList(ovl.add(id)); :}
					| COM var:v
					{: RESULT = new VarList(id);  :}
					| empty
					;*/
					
var			::=		ID:id
					{: RESULT = new Variable(id); :}
					| prefixexp:pe LBRACK exp:e RBRACK
					{: RESULT = new VarTabIndex(pe,e); :}
					| prefixexp:pe DOT ID:id
					{: RESULT = new VarTabIndex(pe,id); :}
					;

namelist    ::=    	ID:id
					{: RESULT = new Name(id); :}  
					| ID:id COM namelist:nl
					{: RESULT = new NameList(nl.add(id)); :} 
					;

explist		::=     exp:e
					{: RESULT = new Exp(e); :}  
					| exp:e COM explist:el
					{: RESULT = new ExpList(el.add(e)); :}  
					;
					
exp			::=		NIL
					{: RESULT = new Nil(); :}  
					| FALSE
					{: RESULT = new BooleanExp(false); :}  
					| TRUE
					{: RESULT = new BooleanExp(true); :} 
					| NUMBER:num
					{: RESULT = new NUMBER(num); :} 
					| ID:id 
					{: RESULT = new TextExp(id); :}
					| PARAMS:pa
					{: RESULT = new Dots(pa); :}
					| FUNC:fun
					{: RESULT = new FunctionExp(fun); :}
					| prefixexp:pe
					{: RESULT = new PreExp(pe); :}
					| tableconstructor:tc
					{: RESULT = new TableConstructor(tc); :}
					| exp:e1 binop:op exp:e2
					{: RESULT = new Binop(e1,op,e2); :}
					| unop:uop exp:e
					{: RESULT = new Unop(uop,e); :}
					;

prefixexp	::=		var:v		
					{: RESULT = new Var(v); :}	
					| functioncall:fc	
					{: RESULT = new PrefixExpFuncCall(fc); :}
					| LPAREN exp:e RPAREN
					{: RESULT = new PrefixExpExp(e); :}
					;

functioncall ::=	prefixexp:pe args:ag
					{: RESULT = new FunctionCall(pe,ag); :}	
					| prefixexp:pe DDOT ID:id args:ag
					{: RESULT = new FunctionCall(pe,ag); :}	
					;
					
					
					
					
					
